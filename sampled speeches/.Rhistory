caption = "M = 30; N = 50; p1 = 0.5; P2 = 0.5; p4 = 0.02; 200 Iterations.",
color = "Turnover Rate (p3)") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
axis.title = element_text(size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 9),
plot.caption = element_text(hjust = 0.5, face = "italic", size = 10),
legend.title = element_text(size = 12),
legend.position = "top"
)
ggplot(combined_df, aes(x = time_periode, y = average_knowledge, color = factor(p3))) +
geom_line(size = 1) +
geom_point(size = 0.8) +
labs(title = "Effect of Turbulence (p4) on Code Knowledge over Time with and Without Turnover (p3).",
subtitle = "Comparing different Turnover Rates on Average Code Knowledge over Time.",
x = "Time Period",
y = "Average Code Knowledge",
caption = "M = 30; N = 50; p1 = 0.5; P2 = 0.5; p4 = 0.02; 200 Iterations.",
color = "Turnover Rate (p3)") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
axis.title = element_text(size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 9),
plot.caption = element_text(hjust = 0.5, face = "italic", size = 10),
legend.title = element_text(size = 12),
legend.position = "top"
)
View(OUTPUT)
getvote <- function(v) {
# The purpose of this function is to produce a vote (majority belief of the
# individuals with superior knowledge compared with the code) and the
# difference between the two votes (k).
# Here I assume that the individuals with beliefs = 0 do not vote (abstain),
# which is a natural proposition when viewed from the political science
# perspective (if one doesn't have an opinion about a certain dimension,
# one abstains from the vote).
# Specifically, the function takes a vector (v) of arbitrary length and
# produces the majority vote and advantage over the second choice. It only
# works with two non-neutral (not 0) beliefs. It can be generalized to more
# values, but further assumption about the rate of code learning (effect of n
# and k) need to be made.
uniqv <- sort(unique(v[v!=0]))  # only sort the non 0 elements
freq <- tabulate(match(v, uniqv))  # find number of occurences
indx_max <- which(freq == max(freq))
k <- max(freq) - min(freq)
if(length(uniqv) == 1) {
# Here we need to eliminate an situation where with only one vote
# the max == min and thus k would be 0 (no code learning)
k <- max(freq)
}
output_ = c(uniqv[indx_max], k)
return(output_)
}
# MODEL VARIABLES  ------------------------
iterations = 200  # number of iteration, originally set to 80 in the paper
time = 50  # iterations until equilibrium, a lazy solution to the steady state problem
m <- 30  # number of dimensions
n <- 50  # number of people
# *vestigal code ####
# p1 <- matrix (0.5, nrow=n)  # speed of socialization for each person
# should introduce additional code to allow for heterogeneity in learning rates
# p2 <- 0.5  # speed of code learning
# end vestigal code ###
p3 <- 0  # turnover
p4 <- 0  # environmental turbulence
# lists forming the parmeter space for the learning rates
P1_list <- c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)
P2_list <- c(0.1, 0.5, 0.9)
# PREPARING THE OUTPUT MATRIX ------
OUTPUT = matrix(0, nrow=length(P1_list), ncol=length(P2_list))
c_p1 <- 0  # counter for recording rows in the OUTPUT file
scenario <- 0  # counter to report progress
# SIMULATION  -----------------
for(p1 in P1_list) {
c_p1 <- c_p1 + 1
c_p2 <- 0  # counter for recording columns in the OUTPUT file
for(p2 in P2_list) {
c_p2 <- c_p2 + 1
scenario <- scenario + 1
for(i in 1:iterations) {
cat("\r","Scenario: ", toString(scenario), " out of ", toString(length(P1_list)*length(P2_list)), ", iteration: ", toString(i))
# Generating starting objects
external_reality <- 2*(floor(runif(m, min=0, max=2))) - 1
beliefs <- matrix(floor(runif(n*m, min=-1, max=2)), nrow=n, ncol=m)
org_code <- numeric(m)
for(t in 1:time) {
# turnover =====
for(x3 in 1:n) {
if(runif(1) < p3) {
beliefs[, x3] <- matrix(floor(runif(m, min=-1, max=2)), nrow=m)
}
}
# environmental turbulence  =====
for(x4 in 1:m) {
if(runif(1) < p4) {
external_reality[x4] <- external_reality[x4]*(-1)
}
}
# socialization ======
for(n_ in 1:n) {
for(m_ in 1:m) {
if(runif(1) < p1) {
# individuals don't learn if code is 0 [page 74, line 27:28]
if(org_code[m_] != 0)  {
beliefs[n_, m_] <- org_code[m_]
}
}
}
}
# end: socialization
# code learning ======
# * choosing the chosen ones (superior knowledge) ######
# find out the quality of knowledge for the code and individuals
knowl_code <- sum(org_code == external_reality)
knowl_wkrs <- numeric(n)  # vector with num of correct dimensions
for(person in 1:n) {
knowl_wkrs[person] <- sum(beliefs[person,] == external_reality)
}
chosen_ones <- numeric(n)  # individuals smarter than the org code
# in the beginning pretty much all workers are better than the code
# which has zero knowledge
for(person in 1:n) {
if(knowl_code < knowl_wkrs[person]) {
chosen_ones[person] <- 1
}
}
# *superior matrix  ######
if(sum(chosen_ones) > 0) {
knowl_matrix <- matrix(0, nrow=sum(chosen_ones), ncol=m)
p <- 1  # counter for the superior people
for(person in 1:n) {
if(chosen_ones[person] == 1) {
knowl_matrix[p,] <- beliefs[person,]
p <- p + 1
}
}
# *learning #####
# Setting up the superior group and its knowledge for the code to learn from it
# As per the paper, org code learns from the majority vote of superior
# group.
for(dimension in 1:m) {
result <- getvote(knowl_matrix[,dimension])
vote <- result[1]
k <- result[2]
if(runif(1) > ((1- p2)^k)) {
org_code[dimension] <- vote
}
}
}
# end: code learning from the individuals
}
# recording results  ======
# For now a crude but working version.
knowl_code <- sum(org_code == external_reality)
OUTPUT[c_p1, c_p2] <- OUTPUT[c_p1, c_p2] + (knowl_code/m)
}
}
}
OUTPUT <- OUTPUT/iterations  # taking the average
# END OF LINE
View(OUTPUT)
##data wrangling
#for p3 = 0
output_df <- as.data.frame(OUTPUT)
View(output_df)
output_df$average_equilibrium_knowledge <- rowMeans(output_df)
View(output_df)
output_df$p1 <- P1_list
View(output_df)
output_long <- pivot_longer(output_df, 1:3, names_to = "p2", values_to = "equilibrium_knowledge" )
View(output_long)
# Plot with ggplot
ggplot(output_long, aes(x = p1, y = average_equilibrium_knowledge, color = factor(p2))) +
geom_line(size = 1) +
geom_point(size = 0.8) +
labs(title = "Effect of Learning Rates (p1, p2) on Average Equilibrium Knowledge",
subtitle = "Comparing different Code Learning Rates on Average Equilibrium Knowledge over Socialization Rate.",
x = "Socialization Rate (p1)",
y = "Average Equilibrium Knowledge",
caption = "M = 30; N = 50; 80 Iterations.",
color = "Code Learning Rate (p3)") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
axis.title = element_text(size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 9),
plot.caption = element_text(hjust = 0.5, face = "italic", size = 10),
legend.title = element_text(size = 12),
legend.position = "top"
)
# Plot with ggplot
ggplot(output_long, aes(x = p1, y = average_equilibrium_knowledge, group = factor(p2))) +
geom_line(size = 1) +
geom_point(size = 0.8) +
labs(title = "Effect of Learning Rates (p1, p2) on Average Equilibrium Knowledge",
subtitle = "Comparing different Code Learning Rates on Average Equilibrium Knowledge over Socialization Rate.",
x = "Socialization Rate (p1)",
y = "Average Equilibrium Knowledge",
caption = "M = 30; N = 50; 80 Iterations.",
color = "Code Learning Rate (p3)") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
axis.title = element_text(size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 9),
plot.caption = element_text(hjust = 0.5, face = "italic", size = 10),
legend.title = element_text(size = 12),
legend.position = "top"
)
View(OUTPUT)
View(OUTPUT)
View(output_long)
output_long$p2 <- rename(output_long[p2, ], 0.1 = V1, 0.5 = V2, 0.9 = V3)
output_long$p2 <- rename(output_long[p2, ], 0.1 == V1, 0.5 == V2, 0.9 == V3)
output_long$p2 <- rename(output_long[p2, ], 0.1 == "V1", 0.5 == "V2", 0.9 == "V3")
output_long$p2 <- recode(output_long[p2, ], 0.1 == "V1", 0.5 == "V2", 0.9 == "V3")
output_long$p2 <- recode(output_long[p2, ], 0.1 = "V1", 0.5 = "V2", 0.9 = "V3")
output_long$p2 <- recode(output_long$p2, 0.1 = "V1", 0.5 = "V2", 0.9 = "V3")
output_long$p2 <- recode(output_long$p2, 0.1 = "V1", 0.5 = "V2", 0.9 = "V3")
library(dplyr)
output_long$p2 <- recode(output_long[p2, ], 0.1 = "V1", 0.5 = "V2", 0.9 = "V3")
output_long$p2 <- recode(output_long[p2, ], "0.1" = "V1", "0.5" = "V2", "0.9" = "V3")
output_long$p2 <- recode(output_long$p2, "0.1" = "V1", "0.5" = "V2", "0.9" = "V3")
View(output_long)
output_long$p2 <- recode(output_long$p2, "0.1" = "V1", "0.5" = "V2", "0.9" = "V3")
View(output_long)
output_long$p2 <- recode(output_long$p2, "0.1" = "V1", "0.5" = "V2", "0.9" = "V3")
output_long$p2 <- recode(output_long$p2, "0.1" = "V1", "0.5" = "V2", "0.9" = "V3")
# Plot with ggplot
ggplot(output_long, aes(x = p1, y = average_equilibrium_knowledge, color = factor(p2))) +
geom_line(size = 1) +
geom_point(size = 0.8) +
labs(title = "Effect of Learning Rates (p1, p2) on Average Equilibrium Knowledge",
subtitle = "Comparing different Code Learning Rates on Average Equilibrium Knowledge over Socialization Rate.",
x = "Socialization Rate (p1)",
y = "Average Equilibrium Knowledge",
caption = "M = 30; N = 50; 80 Iterations.",
color = "Code Learning Rate (p3)") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
axis.title = element_text(size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 9),
plot.caption = element_text(hjust = 0.5, face = "italic", size = 10),
legend.title = element_text(size = 12),
legend.position = "top"
)
# Plot with ggplot
ggplot(output_long, aes(x = p1, y = equilibrium_knowledge, color = factor(p2))) +
geom_line(size = 1) +
geom_point(size = 0.8) +
labs(title = "Effect of Learning Rates (p1, p2) on Average Equilibrium Knowledge",
subtitle = "Comparing different Code Learning Rates on Average Equilibrium Knowledge over Socialization Rate.",
x = "Socialization Rate (p1)",
y = "Average Equilibrium Knowledge",
caption = "M = 30; N = 50; 80 Iterations.",
color = "Code Learning Rate (p3)") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
axis.title = element_text(size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 9),
plot.caption = element_text(hjust = 0.5, face = "italic", size = 10),
legend.title = element_text(size = 12),
legend.position = "top"
)
levels(output_long$p2)
output_df <- rename(output_df[, 1:3], "0.1" = "V1", "0.5" = "V2", "0.9" = "V3")
View(output_df)
output_df$p1 <- P1_list
output_long <- pivot_longer(output_df, 1:3, names_to = "p2", values_to = "equilibrium_knowledge" )
View(output_long)
# Plot with ggplot
ggplot(output_long, aes(x = p1, y = equilibrium_knowledge, color = factor(p2))) +
geom_line(size = 1) +
geom_point(size = 0.8) +
labs(title = "Effect of Learning Rates (p1, p2) on Average Equilibrium Knowledge",
subtitle = "Comparing different Code Learning Rates on Average Equilibrium Knowledge over Socialization Rate.",
x = "Socialization Rate (p1)",
y = "Average Equilibrium Knowledge",
caption = "M = 30; N = 50; 80 Iterations.",
color = "Code Learning Rate (p3)") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
axis.title = element_text(size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 9),
plot.caption = element_text(hjust = 0.5, face = "italic", size = 10),
legend.title = element_text(size = 12),
legend.position = "top"
)
# Plot with ggplot
ggplot(output_long, aes(x = p1, y = equilibrium_knowledge, color = factor(p2))) +
geom_line(size = 1) +
geom_point(size = 0.8) +
labs(title = "Effect of Learning Rates (p1, p2) on Average Equilibrium Knowledge",
subtitle = "Comparing different Code Learning Rates on Equilibrium Knowledge over Socialization Rate.",
x = "Socialization Rate (p1)",
y = "Equilibrium Knowledge",
caption = "M = 30; N = 50; 80 Iterations.",
color = "Code Learning Rate (p3)") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
axis.title = element_text(size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 9),
plot.caption = element_text(hjust = 0.5, face = "italic", size = 10),
legend.title = element_text(size = 12),
legend.position = "top"
)
# Plot with ggplot
ggplot(output_long, aes(x = p1, y = equilibrium_knowledge, color = factor(p2))) +
geom_line(size = 1) +
geom_point(size = 0.8) +
labs(title = "Effect of Learning Rates (p1, p2) on Average Equilibrium Knowledge",
subtitle = "Comparing different Code Learning Rates on Equilibrium Knowledge over Socialization Rate.",
x = "Socialization Rate (p1)",
y = "Average Equilibrium Knowledge",
caption = "M = 30; N = 50; 80 Iterations.",
color = "Code Learning Rate (p3)") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
axis.title = element_text(size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 9),
plot.caption = element_text(hjust = 0.5, face = "italic", size = 10),
legend.title = element_text(size = 12),
legend.position = "top"
)
# Plot with ggplot
ggplot(output_long, aes(x = p1, y = equilibrium_knowledge, color = factor(p2))) +
geom_line(size = 1) +
geom_point(size = 0.8) +
labs(title = "Effect of Learning Rates (p1, p2) on Average Equilibrium Knowledge",
subtitle = "Comparing different Code Learning Rates on Equilibrium Knowledge over Socialization Rate.",
x = "Socialization Rate (p1)",
y = "Average Equilibrium Knowledge",
caption = "M = 30; N = 50; 80 Iterations.",
color = "Code Learning Rate (p3)") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
axis.title = element_text(size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 9),
plot.caption = element_text(hjust = 0.5, face = "italic", size = 10),
legend.title = element_text(size = 12),
legend.position = "top"
)
# Plot with ggplot
ggplot(output_long, aes(x = p1, y = equilibrium_knowledge, color = factor(p2))) +
geom_line(size = 1) +
geom_point(size = 0.8) +
labs(title = "Effect of Learning Rates (p1, p2) on Average Equilibrium Knowledge",
subtitle = "Comparing different Code Learning Rates on Equilibrium Knowledge over Socialization Rate.",
x = "Socialization Rate (p1)",
y = "Average Equilibrium Knowledge",
caption = "M = 30; N = 50; 200 Iterations.",
color = "Code Learning Rate (p3)") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
axis.title = element_text(size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 9),
plot.caption = element_text(hjust = 0.5, face = "italic", size = 10),
legend.title = element_text(size = 12),
legend.position = "top"
)
# Plot with ggplot
ggplot(output_long, aes(x = p1, y = equilibrium_knowledge, color = factor(p2))) +
geom_line(size = 1) +
geom_point(size = 0.8) +
labs(title = "Effect of Learning Rates (p1, p2) on Average Equilibrium Knowledge",
subtitle = "Comparing different Code Learning Rates on Equilibrium Knowledge over Socialization Rate.",
x = "Socialization Rate (p1)",
y = "Average Equilibrium Knowledge",
caption = "M = 30; N = 50; 200 Iterations.",
color = "Code Learning Rate (p3)") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
axis.title = element_text(size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 9),
plot.caption = element_text(hjust = 0.5, face = "italic", size = 10),
legend.title = element_text(size = 12),
legend.position = "top"
)
ggplot(output_long, aes(x = p1, y = equilibrium_knowledge, color = factor(p2))) +
geom_line(size = 1) +
geom_point(size = 0.8) +
labs(title = "Effect of Learning Rates (p1, p2) on Average Equilibrium Knowledge",
subtitle = "Comparing different Code Learning Rates on Equilibrium Knowledge over Socialization Rate.",
x = "Socialization Rate (p1)",
y = "Average Equilibrium Knowledge",
caption = "M = 30; N = 50; 200 Iterations.",
color = "Code Learning Rate (p2)") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 12, face = "bold"),
axis.title = element_text(size = 12),
plot.subtitle = element_text(hjust = 0.5, size = 9),
plot.caption = element_text(hjust = 0.5, face = "italic", size = 10),
legend.title = element_text(size = 12),
legend.position = "top"
)
#merged dataset
setwd("C:/Users/hornu/OneDrive/Master Social Scientific Data Analysis/Courses/SIMM71 - Computational Content Analysis for the Social Sciences/SIMM71---Pragmatism-in-IR/sampled speeches")
#Putin speeches
library(httr)
library(rvest)
library(stringr)
library(openxlsx)
install.packages("httr")
install.packages("rvest")
install.packages("stringr")
install.packages("openxlsx")
install.packages("httr")
install.packages("rvest")
install.packages("stringr")
#merged dataset
setwd("C:/Users/hornu/OneDrive/Master Social Scientific Data Analysis/Courses/SIMM71 - Computational Content Analysis for the Social Sciences/SIMM71---Pragmatism-in-IR/sampled speeches")
#Putin speeches
library(httr)
library(rvest)
library(stringr)
library(openxlsx)
# Base URL for pagination
base_url <- "http://en.kremlin.ru/events/president/transcripts/speeches/page/"
# Number of pages to scrape
num_pages <- 20  # Adjust as needed
# Custom headers to mimic a browser
custom_headers <- c(
"User-Agent" = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36"
)
# Introduce delays
random_delay <- function() {
Sys.sleep(runif(1, 2, 5))  # Random delay between 2 and 5 seconds
}
# Create a list to store results
list_of_dfs <- list()
for (page in 1:num_pages) {
# Introduce a delay to avoid server blocking
random_delay()
# Construct the URL
url <- paste0(base_url, page)
# Make the GET request with custom headers
response <- GET(url, add_headers(.headers = custom_headers))
# Check if the request was successful
if (status_code(response) == 200) {
# Parse the HTML content
website <- read_html(content(response, as = "text"))
# Extract titles - ensure they are not generic elements like "Categories"
titles <- website %>%
html_elements("h3.hentry__title a span.entry-title") %>%
html_text2()
# Extract links - ensure they correspond to titles
links <- website %>%
html_elements("h3.hentry__title a") %>%
html_attr("href") %>%
paste0("http://en.kremlin.ru", .) # Append base URL for full link
# Extract dates - ensure alignment
dates <- website %>%
html_elements("h3.hentry__title span.hentry__meta time.published") %>%
html_text2()
# Combine data into a data frame
page_df <- data.frame(
title = titles,
link = links,
date = dates,
stringsAsFactors = FALSE
)
list_of_dfs[[page]] <- page_df
print(paste0("Finished scraping page ", page))
} else {
warning(paste("Failed to fetch page", page, "with status code:", status_code(response)))
}
}
# Combine all pages into a single data frame
all_speeches <- do.call(rbind, list_of_dfs)
# Randomly sample 10 speeches from the 'all_speeches' dataframe
set.seed(123)  # Set a seed for reproducibility
sampled_speeches <- all_speeches[sample(nrow(all_speeches), 5), ]
# Scrape the full text of speeches
sampled_speeches$raw_text <- NA
for (i in seq_len(nrow(sampled_speeches))) {
random_delay()  # Add delay to mimic human behavior
try({
# Access the individual speech link
speech_url <- sampled_speeches$link[i]
response <- GET(speech_url, add_headers(.headers = custom_headers))
if (status_code(response) == 200) {
speech_page <- read_html(content(response, as = "text"))
# Extract all <p> tags (the text content of the speech)
full_text <- speech_page %>%
html_elements("p") %>%  # Capture all <p> tags, which contain the speech content
html_text2() %>%        # Extract the text
paste(collapse = " ")   # Combine all <p> text into one single string
# Clean up text (remove extra whitespace)
full_text <- gsub("\\s+", " ", full_text)  # Replace multiple spaces with a single space
sampled_speeches$raw_text[i] <- full_text
print(paste0("Scraped text from speech ", i))
} else {
warning(paste("Failed to fetch speech", i, "with status code:", status_code(response)))
}
}, silent = TRUE)
}
# Save the sampled_speeches data frame as a TSV file
write.csv(sampled_speeches, "sampled_Speeches_Russia.csv", row.names = FALSE)
sampled_speeches_loaded <- read.csv("sampled_Speeches_Russia.csv", stringsAsFactors = FALSE)
setwd("C:/Users/hornu/OneDrive/Master Social Scientific Data Analysis/Courses/SIMM71 - Computational Content Analysis for the Social Sciences/SIMM71---Pragmatism-in-IR/sampled speeches")
View(sampled_speeches)
